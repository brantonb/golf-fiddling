<!DOCTYPE html>
<html>
<head>
  <title>Zoom Functionality Test</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }
    pre {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    .pass { color: #0f0; }
    .fail { color: #f00; }
  </style>
</head>
<body>
  <h1>Zoom Functionality Test</h1>
  <pre id="output"></pre>

  <script type="module">
    const output = document.getElementById('output');

    function log(text, pass = null) {
      const span = document.createElement('span');
      if (pass === true) span.className = 'pass';
      if (pass === false) span.className = 'fail';
      span.textContent = text + '\n';
      output.appendChild(span);
    }

    log('=== Testing Coordinate Conversion with Zoom ===\n');

    // Simulate the coordinate conversion that happens in app.js handleClick()
    function testCoordinateConversion(zoomLevel, clickX, clickY, imageWidth, imageHeight) {
      // Image dimensions at current zoom
      const displayWidth = imageWidth * zoomLevel;
      const displayHeight = imageHeight * zoomLevel;

      // Convert click position to game pixels (same formula as app.js)
      const gameX = (clickX / displayWidth) * imageWidth;
      const gameY = (clickY / displayHeight) * imageHeight;

      return { gameX, gameY };
    }

    // Test 1: Verify game pixel conversion at different zoom levels
    log('Test 1: Game Pixel Conversion at Different Zoom Levels');
    log('Original image: 176x304 (Japan Hole 1)');
    log('');

    const imageWidth = 176;
    const imageHeight = 304;

    // Test at 1x zoom
    {
      const zoom = 1;
      // Click at position (88, 152) on 1x image (should be middle: 88, 152 in game pixels)
      const result = testCoordinateConversion(zoom, 88, 152, imageWidth, imageHeight);
      const expectedX = 88;
      const expectedY = 152;
      const passX = Math.abs(result.gameX - expectedX) < 0.01;
      const passY = Math.abs(result.gameY - expectedY) < 0.01;
      log(`  1x zoom: Click (88, 152) → Game (${result.gameX.toFixed(1)}, ${result.gameY.toFixed(1)})`, passX && passY);
      log(`    Expected: (${expectedX}, ${expectedY})`, passX && passY);
    }

    // Test at 2x zoom
    {
      const zoom = 2;
      // Click at position (176, 304) on 2x image (352x608) → should be (88, 152) in game pixels
      const result = testCoordinateConversion(zoom, 176, 304, imageWidth, imageHeight);
      const expectedX = 88;
      const expectedY = 152;
      const passX = Math.abs(result.gameX - expectedX) < 0.01;
      const passY = Math.abs(result.gameY - expectedY) < 0.01;
      log(`  2x zoom: Click (176, 304) → Game (${result.gameX.toFixed(1)}, ${result.gameY.toFixed(1)})`, passX && passY);
      log(`    Expected: (${expectedX}, ${expectedY})`, passX && passY);
    }

    // Test at 4x zoom
    {
      const zoom = 4;
      // Click at position (352, 608) on 4x image (704x1216) → should be (88, 152) in game pixels
      const result = testCoordinateConversion(zoom, 352, 608, imageWidth, imageHeight);
      const expectedX = 88;
      const expectedY = 152;
      const passX = Math.abs(result.gameX - expectedX) < 0.01;
      const passY = Math.abs(result.gameY - expectedY) < 0.01;
      log(`  4x zoom: Click (352, 608) → Game (${result.gameX.toFixed(1)}, ${result.gameY.toFixed(1)})`, passX && passY);
      log(`    Expected: (${expectedX}, ${expectedY})`, passX && passY);
    }

    log('');

    // Test 2: Verify tee position at different zooms
    log('Test 2: Tee Position Click at Different Zooms');
    log('Tee is at game pixel (83, 258)');
    log('');

    const teeX = 83;
    const teeY = 258;

    [1, 2, 3, 4].forEach(zoom => {
      const clickX = teeX * zoom;
      const clickY = teeY * zoom;
      const result = testCoordinateConversion(zoom, clickX, clickY, imageWidth, imageHeight);
      const passX = Math.abs(result.gameX - teeX) < 0.01;
      const passY = Math.abs(result.gameY - teeY) < 0.01;
      log(`  ${zoom}x zoom: Click (${clickX}, ${clickY}) → Game (${result.gameX.toFixed(1)}, ${result.gameY.toFixed(1)})`, passX && passY);
    });

    log('');

    // Test 3: Distance calculation with zoomed coordinates
    log('Test 3: Distance Calculation at Different Zooms');
    log('Measuring from tee (83, 258) to green (64, 47)');
    log('');

    import { MeasurementState } from './measure.js';

    const greenX = 64;
    const greenY = 47;

    [1, 2, 3, 4].forEach(zoom => {
      const state = new MeasurementState();

      // Simulate clicking on tee and green at different zoom levels
      const teeClickX = teeX * zoom;
      const teeClickY = teeY * zoom;
      const greenClickX = greenX * zoom;
      const greenClickY = greenY * zoom;

      // Convert to game pixels
      const teeGamePos = testCoordinateConversion(zoom, teeClickX, teeClickY, imageWidth, imageHeight);
      const greenGamePos = testCoordinateConversion(zoom, greenClickX, greenClickY, imageWidth, imageHeight);

      // Add to measurement state
      state.addPoint(teeGamePos.gameX, teeGamePos.gameY);
      state.addPoint(greenGamePos.gameX, greenGamePos.gameY);

      const distance = state.calculateTotalDistance();
      const expected = 423.7;  // Known distance from previous test
      const pass = Math.abs(distance - expected) < 0.1;

      log(`  ${zoom}x zoom: Distance = ${distance.toFixed(1)}y`, pass);
    });

    log('');
    log('  Expected: 423.7y for all zoom levels', true);

    log('');
    log('=== All Zoom Tests Complete ===', true);
    log('');
    log('Summary:');
    log('✓ Coordinate conversion works correctly at all zoom levels');
    log('✓ Clicking on same game position gives same result regardless of zoom');
    log('✓ Distance calculations are accurate at all zoom levels');
    log('✓ Integer scaling preserves pixel-perfect math');
  </script>
</body>
</html>
